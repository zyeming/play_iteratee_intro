
@[Scala, Markdown]


!SLIDE

#Play中的Iteratee及其用途

!SLIDE left

###About Me
- @看处方
- C -> C++ -> Java -> Scala
- 用Scala开发过:
  - 乐知分享插件
  - 看处方网站
  - 杏仁医生后端

!SLIDE

#Iterator

!SLIDE

###使用Iterator计算数字的总和

```scala
val l = List(1, 2, 3, 4, 5) 
var total = 0 
var it = l.iterator 
while (it.hasNext) {
  total += it.next
}
total
```

!SLIDE

###使用foreach计算数字的总和

```scala
val l = List(1, 2, 3, 4, 5) 
var total = 0
def step(item: Int) = total += item
l foreach step
total
```

!SLIDE

###当然也可以写成这样

```scala
l.foldLeft(0){ (total, elt) => total + elt }
```

!SLIDE

###尝试下自己来实现foreach

```scala
def foreach(l: List[Int]) = {
  def step(l: List[Int], total: Int): Int = {
    l match {
      case List() => total
      case List(elt) => total + elt
      case head :: tail => step(tail, total + head)
    }
  }

  step(l, 0)
}

val l = List(1, 2, 3, 4, 5) 
foreach(l)
```

!SLIDE

###迭代过程

```scala
step(List(1, 2, 3, 4, 5), 0)
step(List(2, 3, 4, 5), 1)
step(List(3, 4, 5), 3)
step(List(4, 5), 6)
step(List(5), 10)
15
```

!SLIDE

#Enumerator

!SLIDE

###Enumerator是Collection的升级版

```scala
// an enumerator of Integers
val integerE: Enumerator[Int] = 
  Enumerate(123, 456, 789)

// an Enumerator from a file
val fileE: Enumerator[Array[Byte]] = 
  Enumerator.fromFile("myfile.txt")

// an Enumerator generated by a callback
// notice the Promise.timeout which is non-block
val dateE: Enumerator[Date] = 
  Enumerator.fromCallback { () => 
    Promise.timeout(Some(new Date), 100 milliseconds) 
  }
```

!SLIDE left

###Enumerator是一个生产者（Producer）。

Enumerator[E]的作用是生成类型为E的数据块。这些数据块的类型是Input[E]，包括：

1. Input.El[E]：类型为E的数据块。
1. Input.Empty：Enumerator为空。
1. Input.EOF：Enumerator已结束。


Enumerator是异步非阻塞的。在没有消费者（Consumer）的情况下，它不会实际生成任何数据。

!SLIDE left

###例如

```scala
val fileE: Enumerator[Array[Byte]] = 
  Enumerator.fromFile("myfile.txt")
```

- 运行到这行代码时，它并没有真正的去读文件。
- 只有把Enumerator和一个消费者绑定时，它才会开始读文件，而且是以异步（类似Future)的方式。
- 每次消费者需要数据时，这个Enumerator会生成一个类型为Input.El[Array[Byte]]的数据块。每个块默认大小为8k，当然最后一个数据块的大小很可能是小于8k的。
- 如果文件已经读完了，这个Enumerator则会生成一个Input.EOF。

!SLIDE

#Iteratee

!SLIDE left

###Iteratee就是函数式编程里的Iterator

Iteratee是Enumerator的消费者（Consumer）。

Iteratee[E, +A]的作用就是接受类型为E的输入，通过一系列的迭代过程，将其转换为类型为A的输出。

!SLIDE 

###用Iteratee实现加和计算

```scala
val iteratee = Iteratee.fold(0){ 
    (total: Int, n: Int) => total + n 
}
val enumerator = Enumerator(1, 2, 3, 4, 5)
enumerator.run(iteratee)    // 返回Future[Int]
```

!SLIDE left

###Iteratee是一个状态机

Iteratee有三种状态：

1. Cont\[E, A](k: Input[E] => Iteratee[E, A])
1. Done(a: A, e: Input[E])
1. Error\[E](msg: String, input: Input[E])

这些状态本身也是Iteratee。

!SLIDE

###自己定义一个Iteratee

```scala
def totalIteratee: Iteratee[Int, Int] = {
  def step(total: Int)(i: Input[Int]): 
  Iteratee[Int, Int] = i match {
    case Input.EOF | Input.Empty => 
      Done(total, Input.EOF)
    case Input.El(e) => 
      Cont[Int, Int](i => step(total + e)(i))
  }
  // 返回一个初始状态的Iteratee
  (Cont[Int, Int](i => step(0)(i)))
}

val enumerator = Enumerator(1, 2, 3, 4, 5)
enumerator.run(totalIteratee)    // 返回Future[Int]
```

*和之前foreach的实现类似，Iteratee每一次迭代时，根据当前的状态，以及从Enumerator得到类型为Input[E]的输入，决定下一步的状态。直到到达Done或Error，或者Enumerator没有更多数据。*

!SLIDE

###迭代过程

```scala
Cont[Int, Int](i => step(0)(i))   // 初始状态
Input.El[Int](1) -> Cont[Int, Int](i => step(1)(i))
Input.El[Int](2) -> Cont[Int, Int](i => step(3)(i))
Input.El[Int](3) -> Cont[Int, Int](i => step(6)(i))
Input.El[Int](4) -> Cont[Int, Int](i => step(10)(i))
Input.El[Int](5) -> Cont[Int, Int](i => step(15)(i))
// 结束状态，Enumerator会从结束状态的Iteratee中抽取出数据
Input.EOF -> Done(15, Input.EOF)  
```

!SLIDE

#Enumeratee

!SLIDE

###Enumeratee是一个Iteratee和Enumerator的适配器

```scala
val enumerator = Enumerator(1, 2, 3, 4, 5)
val iteratee: Iteratee[String, List[String]] = …
val list: List[String] = enumerator.through(
    Enumeratee.map(_.toString) run iteratee)
```

!SLIDE

#Iteratee和Enumerator在Play中的使用

!SLIDE

###Play中HTTP请求的处理都是以Iteratee和Enumerator为基础的。

!SLIDE

###Play的HTTP处理模块本质上就是类型声明如下的API

```scala
RequestHeader -> Array[Byte] -> Result
```

*Play首先获取请求的Header、然后是Body，最后返回一个类型为Result的响应。*

!SLIDE

###Play中Action的类型声明

```scala
trait EssentialAction extends (
  RequestHeader => Iteratee[Array[Byte], Result])
```

*如果把请求Body作为一个数据流，按需处理的话，Iteratee就可以在这里派上用处了。*

!SLIDE

###Play中Action的类型声明

```scala
case class SimpleResult(headers:ResponseHeaders, 
                        body:Enumerator[Array[Byte]])
```

*Result包含两个部分，一个响应Header和一个类型为Array[Byte]的响应Body。同样，如果把响应Body做成一个数据流，按需输出的话，就是一个Enumerator了。*

!SLIDE

###一个Action的例子

```scala
def index = Action {
  SimpleResult(
    header = ResponseHeader(200),
    body = Enumerator("Hello World")
  )
}
```

*可以简写为 Ok("Hello World")*

!SLIDE

###Chunked响应

```scala
def index = Action {
  Ok.chunked(
    Enumerator("kiki", "foo", "bar").
      andThen(Enumerator.eof)
  )
}
```

!SLIDE

###Chunked输出

```
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Transfer-Encoding: chunked

4
kiki
3
foo
3
bar
0
```

!SLIDE

###WebSocket处理

```scala
def index = WebSocket.using[String] { request => 
  // Just consume and ignore the input
  val in = Iteratee.consume[String]()
  // Send a single 'Hello!' message and close
  val out = Enumerator("Hello!").andThen(Enumerator.eof)
  
  (in, out)
}
```

!SLIDE

###WS

```scala
// Make the request (Play 2.3)
val futureResponse: 
  Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = 
    WS.url(url).getStream()

val bytesReturned: Future[Long] = futureResponse.flatMap {
  case (headers, body) =>
    // Count the number of bytes returned
    body |>>> Iteratee.fold(0l) { (total, bytes) =>
      total + bytes.length
    }
}
```

*WS是Play中用于访问外部HTTP应用的库。如果这个请求返回的内容很大，可能就需要用流的方式来处理。*

!SLIDE

#Play页面模块实现

!SLIDE

}}} images/zhou.jpg

## 注意！一大波代码即将来袭！

!SLIDE left

}}} images/kcf.png

##问题：

##如何实现页面侧边栏？

!SLIDE

###实现页面Template

```html
@(..., counts: (Int, Int), tags: List[String])
<html>
  <head>...</head>
  <body>
    ...
    <div class="sidebar">
      @views.html.sidebar.counts(counts)
      @views.html.sidebar.myTags(tags)
    </div>
  </body>
</html>
```

!SLIDE

###实现Action

```scala
def index = Action.async {
  ...
  val counts = getCounts(...)
  val tags = getMyTags(...)
  Ok(views.html.page(..., counts, tags))
}
```

!SLIDE left

###存在的问题

1. 模块性差。
1. 错误处理麻烦。
1. 影响主页面加载。

如何解决？

!SLIDE

###定义侧边栏模块，包括Action及其页面Template

```scala
def currentCounts(): Future[SimpleResult] = future {
  val counts = getCounts(...)
  Ok(views.html.sidebar.counts(counts))
}
```

*注意返回的是Future*

!SLIDE

###将侧边栏模块嵌入主页面Template

```scala
@(..., sidebar: Html)
<html>
  <head>...</head>
  <body>
    ...
    <div class="sidebar">
      @sidebar
    </div>
  </body>
</html>
```

!SLIDE

###主页面Action实现

```scala
def index = Action.async {
  ...
  Pagelet.readBody(
    currentCounts(),
    myTags()
  ).map { sidebar =>
    Ok(views.html.page(..., sidebar))
  }
}

```

!SLIDE

###定义帮助方法

```scala
  // 讲一个SimpleResult转换为Future[String]
  def readBody(result: SimpleResult)(
    implicit codec: Codec): Future[String] = {
    result.body.run(Iteratee.consume()).
      map(bytes => new String(bytes, codec.charset))
  }

  // 将多个Future[SimpleResult]组装成一个Future[Html]
  def readBody(results: Future[SimpleResult]*)(
    implicit codec: Codec): Future[Html] = {
    // 转化为Try，便于做filter
    val contents: Seq[Future[String]]] =
      results.map(_.flatMap(readBody)
    val contentsF = Future.sequence(contents)
    contentsF.map { content => Html(content.mkString)}
  }
```

!SLIDE

#实现BigPipe

!SLIDE

###页面Template

```html
@(sidebar: utils.HtmlStream)
<html>
<head></head>
<body>
  <div class="container">
    <p>内容内容内容！！</p>
    <div class="sidebar">@sidebar</div>
  </div>
</body>
</html>
```

*页面模板为page.scala.stream，注意结尾的stream说明这是一个自定义的Play页面模板。但其内容和普通的html模板没有区别，只是Html的内容都改为HtmlStream。*

!SLIDE

###Action实现

```scala
def index = Action {
  val sidebar = Pagelet.streamBody(
    currentCounts(),
    discusses(),
    myTags()
  )
  Ok.chunked(views.stream.index(sidebar))
}
```

*因为Stream和chunked响应本身就是异步输出，所以不需要async和Future。*

!SLIDE

###添加Play的自定义模板配置（build.sbt）

```scala
play.Keys.templatesTypes ++= Map(
    "stream" -> "utils.HtmlStreamFormat")

play.Keys.templatesImport ++= Vector(
    "utils.HtmlStream", "utils.HtmlStream._")
```

*要实现自定义模板，必须定义一个Appendable类和一个Format类。*

!SLIDE

###定义HtmlStream

```scala
case class HtmlStream(enumerator: Enumerator[Html]) 
  extends Appendable[HtmlStream] {
  def +=(other: HtmlStream): HtmlStream = andThen(other)
  def andThen(other: HtmlStream): HtmlStream = 
    HtmlStream(enumerator.andThen(other.enumerator))
}

object HtmlStream {
  def interleave(streams: HtmlStream*): HtmlStream = {
    HtmlStream(Enumerator.interleave(streams.map(_.enumerator)))
  }
  def flatten(streamF: Future[HtmlStream]): HtmlStream = {
    HtmlStream(Enumerator.flatten(streamF.map(_.enumerator)))
  }
  def apply(text: String): HtmlStream = {
    HtmlStream(Enumerator(Html(text)))
  }
  def apply(eventualText: Future[String]): HtmlStream = {
    flatten(eventualText.map(apply))
  }
}
```


!SLIDE

###定义HtmlStreamFormat

```scala
object HtmlStreamFormat extends Format[HtmlStream] {
  def raw(text: String): HtmlStream = {
    HtmlStream(text)
  }
  def escape(text: String): HtmlStream = {
    raw(HtmlFormat.escape(text).body)
  }
}
```

*HtmlStreamFormat告诉Play如何将模板文件转换为HtmlStream。*

!SLIDE

###定义隐式转换：

```scala
implicit def toEnumerator(
    stream: HtmlStream): Enumerator[Html] = {
  // Skip empty chunks, as these mean EOF
  stream.enumerator.through(
    Enumeratee.filter(!_.body.isEmpty))
}
```

*Ok.chunked接受的参数是Enumerator类型，可以通过隐式转换实现。*

!SLIDE

###最后，定义streamBody方法：

```scala
  // 将多个SimpleResult组装为一个HtmlStream。
  // 因为HtmlStream本身就是异步的，所以没有Future。
  def streamBody(results: Future[SimpleResult]*)(
    implicit codec: Codec): HtmlStream = {

    val contents: Seq[Future[String]] = 
      results.map(_.flatMap(readBody(_)))
    val streams: Seq[HtmlStream] = 
      contents.map(HtmlStream(_))
    HtmlStream.interleave(streams: _*)
  }
```

!SLIDE

###最终结果(curl -raw):

```html
72
<html>
<head></head>
<body>
  <div class="container">
    <p>内容内容内容！！</p>
    <div class="sidebar">
17
这是标签！！<br/>
20
当前帖子量：100！！<br/>
1d
这是热门帖子！！<br/>
1f
</div>
  </div>
</body>
</html>
0
```

!SLIDE

#Q&A
